## Movie Reviewer Database App - Part 4

![Pagination](images/pagination.png)

![Now Playing](images/now-playing.png)

![IMDB](images/IMDB-api-now-playing.png)


## Authentication 

Most applications allow users to register and log in using the credentials they set. The custom credentials prove they are who they say they are.

Authentication is a crucial feature for any application that allows users to create, update, or delete data. Most apps these days would not be complete without authentication because it's what allows users to have an identity on your website or app.

Authentication provides password protection to hide content from unauthorized users. It lets you serve content specifically to a user, as well as customize their settings and experience.

Each time a request is sent to the server, it would need to be authenticated so that the application can ensure that the request is from a valid user and identify the user. The easiest way to do this is by sending the username and password with each and every request.

Theoretically, one could create some kind of session and store this information in a cookie. But sessions are hard to maintain when the application grows with a large number of users and also in cases where there is one than more backend server. So there needs to be a better way.

### Basic Authentication 

The solution is to use `Basic Auth`, which requires sending the credentials with every request, but as a header.

An example:

<strong>Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW1l</strong>

The Basic Authentication scheme is part of the overall authentication framework provided by HTTP (see <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Authentication">this page</a> on MDN web docs for more information).

When the client wants to authenticate itself with a server (for example, log in a user), it can do so by including an Authorization request header with the user credentials. Basic Auth transmits the credentials as user ID/password pairs, which are encoded using an encoding scheme called `base64`.

### JWT (JSON Web Token)

The basic auth approach is fine for a small application with only a few end points (server). But generally, sending the password in each of your requests is not recommended and will make many users uncomfortable. Also, browsers might do things you don’t expect (like caching). 

So, what if you send the username and password only once and get a token with a limited lifespan. You could then just send the token in an encrypted form and the server can make sure that this token is valid. Even if someone picks up the token, there isn’t much they can do as it will expire soon.

That’s exactly what `JWT` does. What’s more, you can even pass some meta information about the user as well.

JSON Web Tokens (JWT) are tokens generated by the server upon user authentication on a web application, and then sent to the client (usually a browser).

To ensure integrity, information contained in the token is signed by a private key, owned by the server. When the server gets the token back from the client, it just has to compare the signature sent by the client with the one it will generate with its private key. If the signatures are identical, the token is then valid.

#### A JWT token is made of the following elements:

 - A "Header" section, containing the algorithm used for the signature, as well as the type of token ("JWT" in our case). The whole thing is encoded in Base64.
 - A "Payload" section, containing the token data, like the user name, date of token generation or expiry date. All of that is written in JSON and also encoded in Base64.
- A "Signature" section, that is the result of Header and Payload, concatenated and then encrypted with the private key.

An example:

Here is an example of a JWT token :

```JS
"Header" section :
{
  "alg": “HS256”,
  "typ": “JWT”
}

"Payload" section :
{
  "iat": 1480929282,
  "exp": 1480932868,
  "name": "Username"
}
```

#### Storing JWT on the Client

<strong>Browser memory (React state).</strong> This will keep it secure from `XSS` (Cross-Site Scripting) but will be lost anytime the user refreshes their browser or re-opens their browser. 

<strong>Local storage or session storage of the browser.</strong>  If the token is stored that way, then it will have to be included in every request sent to the server. The token will be natively protected against`CSRF attacks` considering that the token is unpredictable and cannot be retrieved by an attacke. But the token must be made available to the JavaScript application, it will be exposed in case of `XSS` vulnerabilities and might be stolen.

<strong>Good old fashioned cookies.</strong> When stored in the browser's cookies, it is possible to set the "HttpOnly" flag (and "Secure"), to get protected against token theft in case of XSS attacks.

> Since we are only focused on the front-end, we cannot properly authenticate a user. We will just simulate this method by creating a `token` after a user logs in and storing in a React state variable.

## Environment variables (.env)

An environment variable is a variable whose value is set outside the program, typically through functionality built into the operating system. An environment variable is made up of a name/value pair.

During application initialization, these are loaded into `process.env` and accessed by suffixing the name of the environment variable in your code.

```JS
const API_KEY = process.env.REACT_APP_API_KEY;
```

At runtime, the reference to the environment variable name is replaced with its current value. The primary use case for environment variables is to limit the need to modify and re-release an application due to changes in configuration data.

What to store in environment variables?

 - Execution mode (e.g., production, development, staging, etc.)
 - API URLs
 - Group mail addresses, such as those for marketing, support, sales, etc.
 - Public and private authentication keys (only secure in server applications)

The last item `public and private authentication keys` is where you would store your API key ONLY if it is stored in a back-end server application that you control.  

![env file](images/env-process.png)

> Since we have no back-end server, using an environment variable (.env) is fine for development, just not production.

But remember, anything stored in an .env is <strong>NOT</strong> secure. The values taken from the .env file will be put in the JS code and will be in the source of the bundle file that is parsed and available in the browser.

![bundle file](images/bundle.png)

## Bundle file(s)

Using Create-React-APP which uses Webpack as its file "bundler" merge all the source files into one file called the `bundle file`. 

Bundling is great, but as your app grows, your bundle will grow too. Especially if you are including large third-party libraries. You need to keep an eye on the code you are including in your bundle so that you don’t accidentally make it so large that your app takes a long time to load.

A good site to check the size the resulting bundle file for a package is <a href="https://bundlephobia.com/">bundlephobia</a>.

### Performance Costs

Like any file referenced and used on a website, the bundle file  first needs to be downloaded from a server. Then it need to be parsed, compiled, and then executed. 
 
This is a CPU-intensive operation that blocks the main thread making the page unresponsive for that time.  A user cannot interact with the page during that phase even though the content might be displayed and has seemingly finished loading. 

Also be away that performance is not consistent across devices. There is a wide range of devices available on the market with different CPU and memory specs, so it’s no surprise that the difference in JavaScript execution time between the high-end devices and average devices is huge.

### Code Splitting

To avoid winding up with a large bundle, it's good to get ahead of the problem and start "splittin" your bundle. Code-Splitting is a feature supported by bundlers like Webpack which can create multiple bundles that can be dynamically loaded at runtime.

Code-splitting your app can help you "lazy-load" just the things that are currently needed by the user, which can dramatically improve the performance of your app.

With code-splitting, our goal is to defer the loading, parsing, and execution of JavaScript code which is not needed for the current page or state.

Code splitting is available out-of-the-box for Create React App and other frameworks that use Webpack.

## References
 
- [JWT](https://jwt.io/)
- [Understanding Bundles](https://www.youtube.com/watch?v=MK62LTOt60g)
- [Bundlephobia](https://bundlephobia.com/)
- [Implementing Lazy Loading](https://www.youtube.com/watch?v=nks5rQEZsQg)
- [Understanding Form Validation](https://cxl.com/blog/form-validation/)
- [React Hook Form - Package for Handling Forms](https://react-hook-form.com/)


## Testing

Testing refers to the process of writing tests for our code based on what we expect to happen and then running our code against those tests. Our code will be considered successful if it passes the tests that we write for it. 

The idea is that we determine from the start what we expect a function or a component to do, write tests to reflect these expectations, and then put our components up against these tests. If they behave the way we expect, then we can move on. Otherwise, we need to refactor our code to pass the tests. 

There are several common kinds of testing:

- Unit Testing: Used to test a single function.
- Endpoint Testing: Used to test an endpoint. Postman tests would be an example of this.
- Component Testing/Mocking Components: Testing a component in a simulated environment.
- End to End Testing: Simulates a user interacting with the website.

### Test Driven Development

TDD, is a philosophy of first determining what you want your code to do and writing tests that your code will need to pass, and then writing the code.

TDD often takes place at the level of individual functions.

Test-driven development benefits you, the developer, in the following ways:

- It helps you fully understand the requirements for your function because you have to express them by writing test code. This also helps other people understand your code.
- It helps you relax when code doesn't work. This attitude will help you think more clearly when debugging.
- It helps you fearlessly refactor and improve your code when you need to, because the tests will let you know if you break anything.
- It helps you frequently experience the joy of working code, because getting a test to pass feels great.

Benefits of testing:

- You know exactly what you expect to happen right from the start. This reduces debugging time as it allows you to develop in a more isolated environment
- Allows you to think through your logic beforehand and find any holes you may not have intended.

![Testing](images/testing-overview.png)

To begin applying TDD to a function, follow the process detailed below:

- Determine inputs, outputs, and the function name. Put another way, what does the function do?
- Determine the happy path. The term happy path refers to the common scenario for using a function. So determining the happy path means ignoring any exceptions or odd cases (such as a missing parameter).
- Write the smallest test possible. For example, you may write a test that just checks whether or not the function exists.
- Write code to make the test pass. If you are testing for whether or not the function exists, you may just write the function.
- Repeat steps, updating the test to check for the next step on the road to the happy path. For example, the next test that you write maybe that it returns a value.
- Consider alternative cases and exceptions. For example, what should happen if a parameter is missing?

### Jest

Jest is a unit testing library which allows us to perform unit tests. It comes out of the box with create-react-app. When bootstrapping a project with create-react-app, all of our tests must be included in the `src` directory and will not be compiled on build.

Normally you would either create a `__tests__` folder and keep all of your test files there or create a separate test file with `.test` in the file name (e.g. `app.test.js`).

Jest is a test runner which can be considered your testing environment which runs your test(s). It is also an assertion library which verifies that things are correct or not. It uses Jasmine behind the scenes.

> There are other testing libraries like Mocha (test runner) and Chai (assertion library).

#### Running your tests

When you use `create-react-app` there is a script already created to run your Jest tests:

```npm run test```


```JS
// App.js:

export const add = (value1, value2) => { 
    return value1 + value2;
};

export const total = (shipping, subTotal) => {
    return '$' + add(shipping, subTotal);
};

export function highestScore(students) {
    let result = null;
    let highScore = 0;
  
    for (let i = 0; i < students.length; i++) {
      let student = students[i];
      if (student.score > highScore) {
        highScore = student.score;
        result = student;
      }
    }
  
    return result;
}
```

```JS

// App.test.js:
   
import { add, total, highestScore } from './App';

// unit tests - single function test

test('add - is function defined?', () => {
  expect(add).toBeDefined(); 
});

test('add - is function returning a value?', () => {
  expect(add(1, 2)).toBeDefined();
});

test('add - verify correct return values', () => {
  expect(add(1, 2)).toBe(3);
  expect(add(5, 2)).toBe(7);
});

test('highest score', () => { 
  const students = [
    { name: 'Shane Carey', score: 9.5 },
    { name: 'Rebecca Mills', score: 8.7 },
    { name: 'Derek Myers', score: 9.1 },
  ];
  const result = highestScore(students);
  expect(result).toEqual({ name: 'Shane Carey', score: 9.5 });
});

// integration test - function that relies on another function
test('total', () => {
  expect(total(2, 10)).toBe('$12');
  expect(total(8, 50)).toBe('$58');
});

```

### Testing React Components (React Testing Library)

You can also test entire React components, also called mocking components. To do this you use Facebook's native `React testing library`, which is provided by `create-react-app`. 

This library will allow us to mount our components in a virtual environment and test them.
The goal of the library is to help you write tests that resemble how a user would use your application. It does this by providing utility methods that will query the DOM in the same way a user would. 

> Under the hood, the library uses the DOM Testing Library for the specific DOM methods. As well uses Jest as the testing framework (aka test runner). It also is very common to use Jest-DOM as a utility library that provides extra Jest assertions (e.g. DOM matchers).

```JS

App.jsx:

export default cont App = () => {

    return (
        <>
           <h1>Hello World</h1>
    )
}
```

```JS

App.test.jsx

import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom'; 
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/hello world/i);
  expect(linkElement).toBeInTheDocument();
});

```

The test code above used React Testing Library's <a href="https://testing-library.com/docs/react-testing-library/api/#render">render method</a> to virtually render the App component imported from App.jsx file and append it to the document.body node. You can access the rendered HTML through the <a href="https://testing-library.com/docs/queries/about/#screen">screen object</a>.

> The screen object is part of the core DOM Testing Library.

#### React Testing Library (RTL) Methods for Finding Elements

Most of your React test cases should use methods for finding elements. React Testing Library provides you with several methods to find an element by specific attributes in addition to the getByText() method above:

- <a href="https://testing-library.com/docs/queries/bytext">getByText()</a>: find the element by its textContent value
- <a href="https://testing-library.com/docs/queries/byrole/">getByRole()</a>: by its role attribute value
- <a href="https://testing-library.com/docs/queries/bylabeltext/">getByLabelText()</a>: by its label attribute value
- <a href="https://testing-library.com/docs/queries/byplaceholdertext/">getByPlaceholderText()</a>: by its placeholder attribute value
- <a href="https://testing-library.com/docs/queries/byalttext/">getByAltText()</a>: by its alt attribute value

#### User Generated Events

Aside from finding whether elements are present in your document body, React Testing Library also helps you test user generated events, like clicking on a button and typing values into a textbox.

```JS

// App.jsx:

export default const App = () => {

    const [buttonColor, setButtonColor] = useState('lime');
    const newButtonColor = buttonColor === 'lime' ? 'maroon' : 'lime'; 

    return (

        <button style={{backgroundColor: buttonColor}} 
              onClick={() => setButtonColor(newButtonColor)}>
              Change color
        </button>
    )
}
```

```JS

// App.test.js:
   
import { render, screen, fireEvent } from '@testing-library/react';
import App from '../App'; // root folder (src/App.js)

test('button click caused color change', () => {
    
    render(<App />);
    const button = screen.getByRole('button', { name: 'Change color' });

    // trigger event (button click)
    fireEvent.click(button);
    
    // assertion:
    expect(button).toHaveStyle({
       backgroundColor: 'maroon'
    })

});
```

The test code above uses the `fireEvent` method of the DOM Testing Library to emulate an event of a button click.

## Deployment

[![Netlify Status](https://api.netlify.com/api/v1/badges/ac17a970-2456-4b29-a1da-74910f853945/deploy-status)](https://app.netlify.com/sites/superlative-kitten-43ecf0/deploys)

Your frontend applications can only be hosted locally. If someone wants to view your application, they'll either need to do it on your computer or download your code and run it locally.

Making your application accessible on the web requires you to `deploy` it. Deploying a web application means making it accessible through an URL. 

There are typically three environments you deploy to:

 - The `development` environment on your computer.
 - The `staging` environment references a deployed version used to test changes being made.
 - The `production` environment references a deployed version of the application that is  "complete". This version can be seen by your users.

### The Deployment Process

This requires to recreate your development environment on another machine. That machine which is called a server needs to be configured to run your application on the internet.

Manually deploying a website and setting up an environment is usually knowns as `DevOps`. But there are a number of tools and services that make it much easier.

No matter what service you use, you usually need to follow steps in a particular order.

### Common services

There are a number of services that will host static websites (with HTML, CSS, and JS) for free or for a reduced cost. `GitHub` allows for deploying static websites as well as domain services like `GoDaddy` and Name.com.

One of the most popular solutions, `Amazon Web Services` (AWS) runs the web. Working with AWS can be complicated and costly for newbies, but it's an industry standard for most large applications.

`Heroku` is one of the more popular options, particularly among those who have a full-stack application. They have a command-line interface and can perform many of the same tasks that AWS and Azure can, with less configuratiohn

`Netlify` and `Vercel`, has become more popular as JavaScript has become more popular as both a frontend and backend language. Unlike Heroku, Netlify and Vercel only deploy front-end applications.

### Build Process

The process of preparing your application for production is called `building`. The build process converts your source code into an "executable" bundle to be used by the browser.

The `build` is an artifact which is produced during the build process that includes interpreted source code and compiled assets.

So the `deployment` is the process of putting (deploying) the buils to a server.
- [Formik - Package for Forms](https://formik.org/docs/overview)
- [React Form Validation - Custom Hook](https://www.youtube.com/watch?v=KGFG-yQD7Dw)